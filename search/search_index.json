{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"api-reference/file-conversion/","text":"File conversion \u00b6 Example -> Package.build -> Danger Because Rostruct runs code, and Rojo syncs code to Roblox Studio, some key differences exist in functionality. Not supported Rojo project files Project files structure your codebase around the game object, which would expose your project to the client. Differences .rbxm and .rbxmx files are fully supported, but the former is buggy in Rojo. Known issues *.model.json files do not support Rojo's custom properties like Instance.Tags and LocalizationTable.Content . *.meta.json files infer property types differently than Rojo meta files. Rostruct file conversion mirrors Rojo's sync details . Concepts on the table below will redirect you to their respective Rojo pages. Supported Rojo concepts \u00b6 Concept File Name Supported Folders any directory Server scripts *.server.lua Client scripts *.client.lua Module scripts *.lua XML models *.rbxmx Binary models *.rbxm Localization tables *.csv Plain text *.txt JSON modules *.json JSON models *.model.json Projects *.project.json Meta files *.meta.json","title":"File conversion"},{"location":"api-reference/file-conversion/#file-conversion","text":"Example -> Package.build -> Danger Because Rostruct runs code, and Rojo syncs code to Roblox Studio, some key differences exist in functionality. Not supported Rojo project files Project files structure your codebase around the game object, which would expose your project to the client. Differences .rbxm and .rbxmx files are fully supported, but the former is buggy in Rojo. Known issues *.model.json files do not support Rojo's custom properties like Instance.Tags and LocalizationTable.Content . *.meta.json files infer property types differently than Rojo meta files. Rostruct file conversion mirrors Rojo's sync details . Concepts on the table below will redirect you to their respective Rojo pages.","title":"File conversion"},{"location":"api-reference/file-conversion/#supported-rojo-concepts","text":"Concept File Name Supported Folders any directory Server scripts *.server.lua Client scripts *.client.lua Module scripts *.lua XML models *.rbxmx Binary models *.rbxm Localization tables *.csv Plain text *.txt JSON modules *.json JSON models *.model.json Projects *.project.json Meta files *.meta.json","title":"Supported Rojo concepts"},{"location":"api-reference/globals/","text":"Globals \u00b6 Scripts executed by Rostruct have modified globals to stay consistent with how actual Roblox scripts run. For example, in Rostruct scripts, the require () function is modified to load the ModuleScript objects Rostruct creates, and provides a detailed error traceback for recursive require () calls. Global environments are modified internally with the setfenv () function. Rostruct also adds some extra globals for convenience: _ROOT \u00b6 const _ROOT : string A reference to the Package's root property. _PATH \u00b6 const _PATH : string A path to the Lua file that is being executed.","title":"Globals"},{"location":"api-reference/globals/#globals","text":"Scripts executed by Rostruct have modified globals to stay consistent with how actual Roblox scripts run. For example, in Rostruct scripts, the require () function is modified to load the ModuleScript objects Rostruct creates, and provides a detailed error traceback for recursive require () calls. Global environments are modified internally with the setfenv () function. Rostruct also adds some extra globals for convenience:","title":"Globals"},{"location":"api-reference/globals/#_root","text":"const _ROOT : string A reference to the Package's root property.","title":"_ROOT "},{"location":"api-reference/globals/#_path","text":"const _PATH : string A path to the Lua file that is being executed.","title":"_PATH "},{"location":"api-reference/overview/","text":"API Reference \u00b6 Rostruct is a file execution library, designed for Roblox exploiting with Rojo . Here, you can find documentation for Rostruct's features. Get started \u00b6 Jump directly to the documentation for some common APIs: Rostruct \u00b6 open fetch Package \u00b6 Properties build require","title":"Overview"},{"location":"api-reference/overview/#api-reference","text":"Rostruct is a file execution library, designed for Roblox exploiting with Rojo . Here, you can find documentation for Rostruct's features.","title":"API Reference"},{"location":"api-reference/overview/#get-started","text":"Jump directly to the documentation for some common APIs:","title":"Get started"},{"location":"api-reference/overview/#rostruct","text":"open fetch","title":"Rostruct"},{"location":"api-reference/overview/#package","text":"Properties build require","title":"Package"},{"location":"api-reference/types/","text":"Types \u00b6 Some Rostruct functions may return tables to store data in one place. The structures of these tables are documented on this page. FetchInfo \u00b6 interface FetchInfo { /** The folder the release was saved to. */ readonly location : string ; /** Whether the operation downloaded a new release. */ readonly updated : boolean ; /** The owner of the repository. */ readonly owner : string ; /** The name of the repository. */ readonly repo : string ; /** The version of the release. */ readonly tag : string ; /** The specific asset that was downloaded. */ readonly asset : \"Source code\" | string ; } Represents the status of a GitHub Release fetch operation. FetchInfo is used in a Package object's fetchInfo property. The owner , repo , tag , and asset fields typically reference the arguments passed to a fetch function. If an asset isn't passed to the fetch function, asset defaults to \"Source code\" . The tag field also defaults to the latest stable version of the repository.","title":"Types"},{"location":"api-reference/types/#types","text":"Some Rostruct functions may return tables to store data in one place. The structures of these tables are documented on this page.","title":"Types"},{"location":"api-reference/types/#fetchinfo","text":"interface FetchInfo { /** The folder the release was saved to. */ readonly location : string ; /** Whether the operation downloaded a new release. */ readonly updated : boolean ; /** The owner of the repository. */ readonly owner : string ; /** The name of the repository. */ readonly repo : string ; /** The version of the release. */ readonly tag : string ; /** The specific asset that was downloaded. */ readonly asset : \"Source code\" | string ; } Represents the status of a GitHub Release fetch operation. FetchInfo is used in a Package object's fetchInfo property. The owner , repo , tag , and asset fields typically reference the arguments passed to a fetch function. If an asset isn't passed to the fetch function, asset defaults to \"Source code\" . The tag field also defaults to the latest stable version of the repository.","title":"FetchInfo "},{"location":"api-reference/package/build/","text":"build \u00b6 function build ( fileOrFolder? : string , props ?: {[ prop : string ] : any }) : Instance Constructs a new Instance from a file or folder in the root directory, with the properties props . Instances returned by this function can also be found in Package.tree . If fileOrFolder is a string, the function transforms Package . root .. fileOrFolder . If fileOrFolder is nil , the function transforms the root directory. You can see how files turn into Roblox objects on the file conversion page . Tip Model files ( *.rbxm , *.rbxmx ) that contain LocalScript and ModuleScript instances act just like normal Rostruct scripts - but the _PATH global points to the model file. Caution Avoid building the root directory if it contains files Rostruct shouldn't use. It's good practice to store your source code in a specific folder in your project. Parameters \u00b6 fileOrFolder? : string | undefined - The file or folder to build; Defaults to the root directory props ?: {[ prop : string ] : any } | undefined - A map of properties to apply to the instance Example usage \u00b6 local package = Rostruct . open ( \"PathTo/MyProject/\" ) package : build ( \"src/\" , { Name = \"MyProject\" , }) package : build ( \"stringValue.txt\" , { Name = \"MyString\" , Value = \"Hi\" , }) print ( package . tree . MyString . Value ) --> Hi","title":"build"},{"location":"api-reference/package/build/#build","text":"function build ( fileOrFolder? : string , props ?: {[ prop : string ] : any }) : Instance Constructs a new Instance from a file or folder in the root directory, with the properties props . Instances returned by this function can also be found in Package.tree . If fileOrFolder is a string, the function transforms Package . root .. fileOrFolder . If fileOrFolder is nil , the function transforms the root directory. You can see how files turn into Roblox objects on the file conversion page . Tip Model files ( *.rbxm , *.rbxmx ) that contain LocalScript and ModuleScript instances act just like normal Rostruct scripts - but the _PATH global points to the model file. Caution Avoid building the root directory if it contains files Rostruct shouldn't use. It's good practice to store your source code in a specific folder in your project.","title":"build"},{"location":"api-reference/package/build/#parameters","text":"fileOrFolder? : string | undefined - The file or folder to build; Defaults to the root directory props ?: {[ prop : string ] : any } | undefined - A map of properties to apply to the instance","title":"Parameters"},{"location":"api-reference/package/build/#example-usage","text":"local package = Rostruct . open ( \"PathTo/MyProject/\" ) package : build ( \"src/\" , { Name = \"MyProject\" , }) package : build ( \"stringValue.txt\" , { Name = \"MyString\" , Value = \"Hi\" , }) print ( package . tree . MyString . Value ) --> Hi","title":"Example usage"},{"location":"api-reference/package/properties/","text":"Package \u00b6 A Package is an object that represents a Roblox project. It exposes most of Rostruct's project building API and handles Lua script runtime. Properties \u00b6 Properties are public fields exposed by a Package object. For example, you can access Package.tree like this: local package = Rostruct . open ( \"MyProject\" ) print ( package . tree ) --> Tree tree \u00b6 readonly tree : Folder A Folder object containing all objects returned by the Package.build method. This property helps simplify Promise usage, since you don't need to store the result of the Package.build method to require a module. root \u00b6 readonly root : string A reference to the root directory of the project, which was passed into the Rostruct.open function, or automatically provided when fetching through GitHub. The value should always end with a forward slash! fetchInfo \u00b6 readonly fetchInfo? : FetchInfo | undefined An object that stores data about the last Rostruct.fetch or Rostruct.fetchLatest operation. See the FetchInfo documentation for more info on how it's structured.","title":"Properties"},{"location":"api-reference/package/properties/#package","text":"A Package is an object that represents a Roblox project. It exposes most of Rostruct's project building API and handles Lua script runtime.","title":"Package"},{"location":"api-reference/package/properties/#properties","text":"Properties are public fields exposed by a Package object. For example, you can access Package.tree like this: local package = Rostruct . open ( \"MyProject\" ) print ( package . tree ) --> Tree","title":"Properties"},{"location":"api-reference/package/properties/#tree","text":"readonly tree : Folder A Folder object containing all objects returned by the Package.build method. This property helps simplify Promise usage, since you don't need to store the result of the Package.build method to require a module.","title":"tree "},{"location":"api-reference/package/properties/#root","text":"readonly root : string A reference to the root directory of the project, which was passed into the Rostruct.open function, or automatically provided when fetching through GitHub. The value should always end with a forward slash!","title":"root "},{"location":"api-reference/package/properties/#fetchinfo","text":"readonly fetchInfo? : FetchInfo | undefined An object that stores data about the last Rostruct.fetch or Rostruct.fetchLatest operation. See the FetchInfo documentation for more info on how it's structured.","title":"fetchInfo "},{"location":"api-reference/package/require/","text":"require \u00b6 function require ( module : ModuleScript ) : Promise < unknown > Runs module if it has not been run already, and returns what the ModuleScript returned. The module parameter must be a ModuleScript created with the build method. The function returns a Promise object for convenience. Use the requireAsync function if you want to wait for the result instead. Parameters \u00b6 module : ModuleScript - The Rostruct module to load Example usage \u00b6 require local package = Rostruct . open ( \"PathTo/MyModule/\" ) package : build ( \"src/\" , { Name = \"MyModule\" , }) package : require ( package . tree . MyModule ) : andThen ( function ( MyModule ) MyModule . DoSomething () end ) requireAsync local package = Rostruct . open ( \"PathTo/MyModule/\" ) package : build ( \"src/\" , { Name = \"MyModule\" , }) local MyModule = package : requireAsync ( package . tree . MyModule ) MyModule . DoSomething ()","title":"require"},{"location":"api-reference/package/require/#require","text":"function require ( module : ModuleScript ) : Promise < unknown > Runs module if it has not been run already, and returns what the ModuleScript returned. The module parameter must be a ModuleScript created with the build method. The function returns a Promise object for convenience. Use the requireAsync function if you want to wait for the result instead.","title":"require "},{"location":"api-reference/package/require/#parameters","text":"module : ModuleScript - The Rostruct module to load","title":"Parameters"},{"location":"api-reference/package/require/#example-usage","text":"require local package = Rostruct . open ( \"PathTo/MyModule/\" ) package : build ( \"src/\" , { Name = \"MyModule\" , }) package : require ( package . tree . MyModule ) : andThen ( function ( MyModule ) MyModule . DoSomething () end ) requireAsync local package = Rostruct . open ( \"PathTo/MyModule/\" ) package : build ( \"src/\" , { Name = \"MyModule\" , }) local MyModule = package : requireAsync ( package . tree . MyModule ) MyModule . DoSomething ()","title":"Example usage"},{"location":"api-reference/package/start/","text":"start \u00b6 function start () : Promise < LocalScript [] > Runs every LocalScript created with the build method after the next Heartbeat event. The function returns a Promise that resolves once every script finishes executing. The Promise cancels if any of the scripts throw an error on the root scope 1 , but the rest of the scripts will continue. Script timeout After ten seconds of suspended execution from any script, the Promise will cancel. Code within the root scope 1 of any LocalScript or ModuleScript should try to finish ASAP, and should avoid yielding if possible! Example usage \u00b6 local package = Rostruct . open ( \"PathTo/MyModule/\" ) package : build ( \"src/\" , { Name = \"MyModule\" }) package : start () : andThen ( function ( scripts ) print ( \"Scripts executed:\" ) for _ , script in ipairs ( scripts ) do print ( script : GetFullName ()) end end ) : catch ( function ( err ) if Promise . Error . isKind ( err , Promise . Error . Kind . TimedOut ) then warn ( \"Script execution timed out!\" ) else warn ( \"Something went wrong: \" .. tostring ( err )) end end ) Refers to the main thread the script is running in, and does not include functions spawned on different threads. \u21a9 \u21a9","title":"start"},{"location":"api-reference/package/start/#start","text":"function start () : Promise < LocalScript [] > Runs every LocalScript created with the build method after the next Heartbeat event. The function returns a Promise that resolves once every script finishes executing. The Promise cancels if any of the scripts throw an error on the root scope 1 , but the rest of the scripts will continue. Script timeout After ten seconds of suspended execution from any script, the Promise will cancel. Code within the root scope 1 of any LocalScript or ModuleScript should try to finish ASAP, and should avoid yielding if possible!","title":"start "},{"location":"api-reference/package/start/#example-usage","text":"local package = Rostruct . open ( \"PathTo/MyModule/\" ) package : build ( \"src/\" , { Name = \"MyModule\" }) package : start () : andThen ( function ( scripts ) print ( \"Scripts executed:\" ) for _ , script in ipairs ( scripts ) do print ( script : GetFullName ()) end end ) : catch ( function ( err ) if Promise . Error . isKind ( err , Promise . Error . Kind . TimedOut ) then warn ( \"Script execution timed out!\" ) else warn ( \"Something went wrong: \" .. tostring ( err )) end end ) Refers to the main thread the script is running in, and does not include functions spawned on different threads. \u21a9 \u21a9","title":"Example usage"},{"location":"api-reference/rostruct/clearcache/","text":"clearCache \u00b6 function clearCache () Clears the Rostruct GitHub Release cache that is used by the fetch and fetchLatest functions. Don't use this in your projects! This function should be used by the end user for troubleshooting only. Example usage \u00b6 Because the cache is cleared, this code always redownloads Roact: Rostruct . clearCache () local package = Rostruct . fetch ( \"Roblox\" , \"roact\" , \"v1.4.0\" )","title":"clearCache"},{"location":"api-reference/rostruct/clearcache/#clearcache","text":"function clearCache () Clears the Rostruct GitHub Release cache that is used by the fetch and fetchLatest functions. Don't use this in your projects! This function should be used by the end user for troubleshooting only.","title":"clearCache  "},{"location":"api-reference/rostruct/clearcache/#example-usage","text":"Because the cache is cleared, this code always redownloads Roact: Rostruct . clearCache () local package = Rostruct . fetch ( \"Roblox\" , \"roact\" , \"v1.4.0\" )","title":"Example usage"},{"location":"api-reference/rostruct/fetch/","text":"fetch \u00b6 function fetch ( owner : string , repo : string , tag : string , asset? : string ) : Promise < Package > Constructs a new Package object from the GitHub Release, with a defined fetchInfo property. When using this function, the asset gets saved to a local cache, which makes future fetch calls for the same asset resolve right away. Zip files are extracted using a modified version of the zzlib library. The function returns a Promise object for convenience. Use the fetchAsync function if you want to wait for the result instead. Fetching from a large repository When the asset field is undefined, the source code of the release will be downloaded. Because Rostruct uses a Lua zip library to extract .zip files, there may be performance issues when extracting large files. Prefer to upload an asset for files you want to run in Rostruct. Parameters \u00b6 owner : string - The owner of the repository repo : string - The name of the repository tag : string - The tag version to download asset? : string | undefined - Optional asset to download; If not specified, it downloads the source files Example usage \u00b6 This example loads Roact v1.4.0: fetch local Roact = Rostruct . fetch ( \"Roblox\" , \"roact\" , \"v1.4.0\" ) : andThen ( function ( package ) if package . fetchInfo . updated then print ( \"First time installation!\" ) end package : build ( \"src/\" , { Name = \"Roact\" }) return package : require ( package . tree . Roact ) end ) : catch ( function ( err ) warn ( \"Error loading Roact:\" , err ) end ) : expect () fetchAsync local package = Rostruct . fetchAsync ( \"Roblox\" , \"roact\" , \"v1.4.0\" ) if package . fetchInfo . updated then print ( \"First time installation!\" ) end package : build ( \"src/\" , { Name = \"Roact\" }) local Roact = package : requireAsync ( package . tree . Roact )","title":"fetch"},{"location":"api-reference/rostruct/fetch/#fetch","text":"function fetch ( owner : string , repo : string , tag : string , asset? : string ) : Promise < Package > Constructs a new Package object from the GitHub Release, with a defined fetchInfo property. When using this function, the asset gets saved to a local cache, which makes future fetch calls for the same asset resolve right away. Zip files are extracted using a modified version of the zzlib library. The function returns a Promise object for convenience. Use the fetchAsync function if you want to wait for the result instead. Fetching from a large repository When the asset field is undefined, the source code of the release will be downloaded. Because Rostruct uses a Lua zip library to extract .zip files, there may be performance issues when extracting large files. Prefer to upload an asset for files you want to run in Rostruct.","title":"fetch  "},{"location":"api-reference/rostruct/fetch/#parameters","text":"owner : string - The owner of the repository repo : string - The name of the repository tag : string - The tag version to download asset? : string | undefined - Optional asset to download; If not specified, it downloads the source files","title":"Parameters"},{"location":"api-reference/rostruct/fetch/#example-usage","text":"This example loads Roact v1.4.0: fetch local Roact = Rostruct . fetch ( \"Roblox\" , \"roact\" , \"v1.4.0\" ) : andThen ( function ( package ) if package . fetchInfo . updated then print ( \"First time installation!\" ) end package : build ( \"src/\" , { Name = \"Roact\" }) return package : require ( package . tree . Roact ) end ) : catch ( function ( err ) warn ( \"Error loading Roact:\" , err ) end ) : expect () fetchAsync local package = Rostruct . fetchAsync ( \"Roblox\" , \"roact\" , \"v1.4.0\" ) if package . fetchInfo . updated then print ( \"First time installation!\" ) end package : build ( \"src/\" , { Name = \"Roact\" }) local Roact = package : requireAsync ( package . tree . Roact )","title":"Example usage"},{"location":"api-reference/rostruct/fetchlatest/","text":"fetchLatest \u00b6 function fetchLatest ( owner : string , repo : string , asset? : string ) : Promise < Package > Constructs a new Package object from the latest stable GitHub Release, with a defined fetchInfo property. When using this function, the asset gets saved to a local cache. However, this function will always make an HTTP request to get the latest release tag. Zip files are extracted using a modified version of the zzlib library. Unlike Rostruct.fetch , this function does not load release drafts or prereleases. The function returns a Promise object for convenience. Use the fetchLatestAsync function if you want to wait for the result instead. Fetching from a large repository When the asset field is undefined, the source code of the release will be downloaded. Because Rostruct uses a Lua zip library to extract .zip files, there may be performance issues when extracting large files. Prefer to upload an asset for files you want to run in Rostruct. Parameters \u00b6 owner : string - The owner of the repository repo : string - The name of the repository asset? : string | undefined - Optional asset to download; If not specified, it downloads the source files Example usage \u00b6 This example loads the latest stable release of Roact : fetchLatest local Roact = Rostruct . fetchLatest ( \"Roblox\" , \"roact\" ) : andThen ( function ( package ) if package . fetchInfo . updated then print ( \"Upgraded to version \" .. package . fetchInfo . tag ) end package : build ( \"src/\" , { Name = \"Roact\" }) return package : require ( package . tree . Roact ) end ) : catch ( function ( err ) warn ( \"Error loading Roact:\" , err ) end ) : expect () fetchLatestAsync local package = Rostruct . fetchLatestAsync ( \"Roblox\" , \"roact\" ) if package . fetchInfo . updated then print ( \"Upgraded to version \" .. package . fetchInfo . tag ) end package : build ( \"src/\" , { Name = \"Roact\" }) local Roact = package : requireAsync ( package . tree . Roact )","title":"fetchLatest"},{"location":"api-reference/rostruct/fetchlatest/#fetchlatest","text":"function fetchLatest ( owner : string , repo : string , asset? : string ) : Promise < Package > Constructs a new Package object from the latest stable GitHub Release, with a defined fetchInfo property. When using this function, the asset gets saved to a local cache. However, this function will always make an HTTP request to get the latest release tag. Zip files are extracted using a modified version of the zzlib library. Unlike Rostruct.fetch , this function does not load release drafts or prereleases. The function returns a Promise object for convenience. Use the fetchLatestAsync function if you want to wait for the result instead. Fetching from a large repository When the asset field is undefined, the source code of the release will be downloaded. Because Rostruct uses a Lua zip library to extract .zip files, there may be performance issues when extracting large files. Prefer to upload an asset for files you want to run in Rostruct.","title":"fetchLatest  "},{"location":"api-reference/rostruct/fetchlatest/#parameters","text":"owner : string - The owner of the repository repo : string - The name of the repository asset? : string | undefined - Optional asset to download; If not specified, it downloads the source files","title":"Parameters"},{"location":"api-reference/rostruct/fetchlatest/#example-usage","text":"This example loads the latest stable release of Roact : fetchLatest local Roact = Rostruct . fetchLatest ( \"Roblox\" , \"roact\" ) : andThen ( function ( package ) if package . fetchInfo . updated then print ( \"Upgraded to version \" .. package . fetchInfo . tag ) end package : build ( \"src/\" , { Name = \"Roact\" }) return package : require ( package . tree . Roact ) end ) : catch ( function ( err ) warn ( \"Error loading Roact:\" , err ) end ) : expect () fetchLatestAsync local package = Rostruct . fetchLatestAsync ( \"Roblox\" , \"roact\" ) if package . fetchInfo . updated then print ( \"Upgraded to version \" .. package . fetchInfo . tag ) end package : build ( \"src/\" , { Name = \"Roact\" }) local Roact = package : requireAsync ( package . tree . Roact )","title":"Example usage"},{"location":"api-reference/rostruct/open/","text":"open \u00b6 function open ( rootDirectory : string ) : Package Constructs a new Package object from the given folder. Parameters \u00b6 rootDirectory : string - A path to the Roblox project Example usage \u00b6 local package = Rostruct . open ( \"projects/MyProject/\" ) package : build ( \"src/\" , { Name = \"MyProject\" }) package : start ()","title":"open"},{"location":"api-reference/rostruct/open/#open","text":"function open ( rootDirectory : string ) : Package Constructs a new Package object from the given folder.","title":"open "},{"location":"api-reference/rostruct/open/#parameters","text":"rootDirectory : string - A path to the Roblox project","title":"Parameters"},{"location":"api-reference/rostruct/open/#example-usage","text":"local package = Rostruct . open ( \"projects/MyProject/\" ) package : build ( \"src/\" , { Name = \"MyProject\" }) package : start ()","title":"Example usage"},{"location":"featured/community/","text":"Featured \u00b6 To get a better understanding of Rostruct, seeing real-world examples may help. How to get featured \u00b6 If you'd like your script featured here, contact 0866#3049 on Discord, or send a PM to 0866 on V3rmillion Community \u00b6 MidiPlayer by 0866 \u00b6 A midi file auto-player for Roblox piano games. Notable features UI stored in a *.rbxm file A single LocalScript initializes the code Uses common utility modules Example","title":"Community"},{"location":"featured/community/#featured","text":"To get a better understanding of Rostruct, seeing real-world examples may help.","title":"Featured"},{"location":"featured/community/#how-to-get-featured","text":"If you'd like your script featured here, contact 0866#3049 on Discord, or send a PM to 0866 on V3rmillion","title":"How to get featured"},{"location":"featured/community/#community","text":"","title":"Community"},{"location":"featured/community/#midiplayer-by-0866","text":"A midi file auto-player for Roblox piano games. Notable features UI stored in a *.rbxm file A single LocalScript initializes the code Uses common utility modules Example","title":"MidiPlayer by 0866"},{"location":"getting-started/creating-your-project/","text":"Creating your project \u00b6 Rostruct turns your Lua projects into Roblox objects and handles script runtime for you. Essentially, it's like Rojo , but for Roblox script execution. So, before you start, remember that you can safely use the script and require () globals in your project. Every Lua script is loaded with a modified global environment , making it nearly identical to running a LocalScript or ModuleScript. See the execution model for an example with asset management. Setup \u00b6 To set up a project, locate your executor's workspace/ directory and create a folder somewhere to host your project. You can initialize a project with Rojo. However, if you don't have Rojo, you should create a folder that stores the source code of your project, and that's all you need to start coding. Sync to Roblox as you write \u00b6 With Rojo , your project files sync to Roblox Studio in real-time. This can be an alternative to frequently restarting Roblox to test your code. You can get Rojo for VS Code , which will install both the Rojo Roblox Studio plugin and the command-line interface. Building your project \u00b6 Once you're ready to test your local project, you can build it with: local Rostruct -- Method to load Rostruct goes here local package = Rostruct . open ( \"projects/MyProject/\" ) local build = package : build ( \"src/\" , { Name = \"MyProject\" }) Then, you can run every LocalScript in the project, or require a specific module: -- Run all LocalScripts after the next Heartbeat event package : start () -- Require a specific module local MyModule = package : require ( build . MyModule ) For complete documentation, check out the API reference . Setting build metadata \u00b6 Some scripts need to know the top-level instance to access other objects, like this: local myProject = script : FindFirstAncestor ( \"MyProject\" ) local Roact = require ( myProject . Modules . Roact ) local character = myProject . Assets . Character Typically, in Rojo, that instance's name can be set in the *.project.json file. However, Rostruct does not (and likely never will!) support Rojo project files. Though this can be achieved with the props argument in the Package:build method, you can also use meta files to keep things simple. Meta files are a powerful tool from Rojo that tells Rostruct how to create the Instance for a specific file. For example, this meta file changes the name of the parent folder, src/ : src/init.meta.json { \"properties\" : { \"Name\" : \"MyProject\" } } For more details, see Rojo's page on meta files .","title":"Creating your project"},{"location":"getting-started/creating-your-project/#creating-your-project","text":"Rostruct turns your Lua projects into Roblox objects and handles script runtime for you. Essentially, it's like Rojo , but for Roblox script execution. So, before you start, remember that you can safely use the script and require () globals in your project. Every Lua script is loaded with a modified global environment , making it nearly identical to running a LocalScript or ModuleScript. See the execution model for an example with asset management.","title":"Creating your project"},{"location":"getting-started/creating-your-project/#setup","text":"To set up a project, locate your executor's workspace/ directory and create a folder somewhere to host your project. You can initialize a project with Rojo. However, if you don't have Rojo, you should create a folder that stores the source code of your project, and that's all you need to start coding.","title":"Setup"},{"location":"getting-started/creating-your-project/#sync-to-roblox-as-you-write","text":"With Rojo , your project files sync to Roblox Studio in real-time. This can be an alternative to frequently restarting Roblox to test your code. You can get Rojo for VS Code , which will install both the Rojo Roblox Studio plugin and the command-line interface.","title":"Sync to Roblox as you write"},{"location":"getting-started/creating-your-project/#building-your-project","text":"Once you're ready to test your local project, you can build it with: local Rostruct -- Method to load Rostruct goes here local package = Rostruct . open ( \"projects/MyProject/\" ) local build = package : build ( \"src/\" , { Name = \"MyProject\" }) Then, you can run every LocalScript in the project, or require a specific module: -- Run all LocalScripts after the next Heartbeat event package : start () -- Require a specific module local MyModule = package : require ( build . MyModule ) For complete documentation, check out the API reference .","title":"Building your project"},{"location":"getting-started/creating-your-project/#setting-build-metadata","text":"Some scripts need to know the top-level instance to access other objects, like this: local myProject = script : FindFirstAncestor ( \"MyProject\" ) local Roact = require ( myProject . Modules . Roact ) local character = myProject . Assets . Character Typically, in Rojo, that instance's name can be set in the *.project.json file. However, Rostruct does not (and likely never will!) support Rojo project files. Though this can be achieved with the props argument in the Package:build method, you can also use meta files to keep things simple. Meta files are a powerful tool from Rojo that tells Rostruct how to create the Instance for a specific file. For example, this meta file changes the name of the parent folder, src/ : src/init.meta.json { \"properties\" : { \"Name\" : \"MyProject\" } } For more details, see Rojo's page on meta files .","title":"Setting build metadata"},{"location":"getting-started/execution-model/","text":"Execution model \u00b6 Asset management \u00b6 A useful pattern is to keep all assets within your project for immediate access. Let's say a project is structured like such: src/ Assets/ Character.rbxm (Model) Controllers/ MyController.lua (ModuleScript) Util/ Signal.lua (ModuleScript) Date.lua (ModuleScript) Thread.lua (ModuleScript) init.meta.json (Renames 'src' to 'MyProject') We can get other modules and assets in MyController.lua with this code: -- MyProject/Controllers/MyController.lua local myProject = script : FindFirstAncestor ( \"MyProject\" ) local Signal = require ( myProject . Util . Signal ) local Date = require ( myProject . Util . Date ) local Thread = require ( myProject . Util . Thread ) local character = myProject . Assets . Character Tip If you need a specific file, scripts run with Rostruct contain the _ROOT and _PATH globals to access the root directory and the current file location, respectively. Catching Rostruct errors \u00b6 Functions like Rostruct.fetch and Package:require use Promises to manage yielding and error handling. Errors thrown during runtime can be caught using the Promise : catch () method: package : start () : catch ( function ( err ) if Promise . Error . isKind ( err , Promise . Error . Kind . TimedOut ) then warn ( \"Script execution timed out!\" ) else warn ( \"Something went wrong: \" .. tostring ( err )) end end ) Best practices \u00b6 Only one LocalScript, if any, should manage module runtime Code should not rely on services like CollectionService that expose you to the client, so use an alternative LocalScripts should try to finish ASAP and avoid yielding the main thread if possible The codebase should never be exposed to the game object to prevent security vulnerabilities","title":"Execution model"},{"location":"getting-started/execution-model/#execution-model","text":"","title":"Execution model"},{"location":"getting-started/execution-model/#asset-management","text":"A useful pattern is to keep all assets within your project for immediate access. Let's say a project is structured like such: src/ Assets/ Character.rbxm (Model) Controllers/ MyController.lua (ModuleScript) Util/ Signal.lua (ModuleScript) Date.lua (ModuleScript) Thread.lua (ModuleScript) init.meta.json (Renames 'src' to 'MyProject') We can get other modules and assets in MyController.lua with this code: -- MyProject/Controllers/MyController.lua local myProject = script : FindFirstAncestor ( \"MyProject\" ) local Signal = require ( myProject . Util . Signal ) local Date = require ( myProject . Util . Date ) local Thread = require ( myProject . Util . Thread ) local character = myProject . Assets . Character Tip If you need a specific file, scripts run with Rostruct contain the _ROOT and _PATH globals to access the root directory and the current file location, respectively.","title":"Asset management"},{"location":"getting-started/execution-model/#catching-rostruct-errors","text":"Functions like Rostruct.fetch and Package:require use Promises to manage yielding and error handling. Errors thrown during runtime can be caught using the Promise : catch () method: package : start () : catch ( function ( err ) if Promise . Error . isKind ( err , Promise . Error . Kind . TimedOut ) then warn ( \"Script execution timed out!\" ) else warn ( \"Something went wrong: \" .. tostring ( err )) end end )","title":"Catching Rostruct errors"},{"location":"getting-started/execution-model/#best-practices","text":"Only one LocalScript, if any, should manage module runtime Code should not rely on services like CollectionService that expose you to the client, so use an alternative LocalScripts should try to finish ASAP and avoid yielding the main thread if possible The codebase should never be exposed to the game object to prevent security vulnerabilities","title":"Best practices"},{"location":"getting-started/installation/","text":"Installation \u00b6 Learn how to integrate Rostruct into your workflow. Warning Automatically getting the latest Rostruct release is discouraged, as breaking changes can happen at any time. Read the latest release's description when updating Rostruct just in case you need to change your code. Rostruct is distributed as a Lua file. Before starting your local project, you should learn how to load Rostruct. with HTTP GET recommended \u00b6 Rostruct can be loaded with HttpGetAsync : local Rostruct = loadstring ( game : HttpGetAsync ( \"https://github.com/richie0866/Rostruct/releases/download/\" .. \"TAG_VERSION_HERE\" .. \"/Rostruct.lua\" ))() This will load the Rostruct script for the given GitHub Release tag version . with loadfile () \u00b6 If you'd rather avoid yielding, you can load Rostruct locally. To do this, save the latest Rostruct.lua file from the GitHub Releases page somewhere in your executor's workspace/ directory. You can load the Lua file with: loadfile local Rostruct = loadfile ( \"Rostruct.lua\" )() loadstring-readfile local Rostruct = loadstring ( readfile ( \"Rostruct.lua\" ))()","title":"Installation"},{"location":"getting-started/installation/#installation","text":"Learn how to integrate Rostruct into your workflow. Warning Automatically getting the latest Rostruct release is discouraged, as breaking changes can happen at any time. Read the latest release's description when updating Rostruct just in case you need to change your code. Rostruct is distributed as a Lua file. Before starting your local project, you should learn how to load Rostruct.","title":"Installation"},{"location":"getting-started/installation/#with-http-get-recommended","text":"Rostruct can be loaded with HttpGetAsync : local Rostruct = loadstring ( game : HttpGetAsync ( \"https://github.com/richie0866/Rostruct/releases/download/\" .. \"TAG_VERSION_HERE\" .. \"/Rostruct.lua\" ))() This will load the Rostruct script for the given GitHub Release tag version .","title":"with HTTP GET"},{"location":"getting-started/installation/#with-loadfile","text":"If you'd rather avoid yielding, you can load Rostruct locally. To do this, save the latest Rostruct.lua file from the GitHub Releases page somewhere in your executor's workspace/ directory. You can load the Lua file with: loadfile local Rostruct = loadfile ( \"Rostruct.lua\" )() loadstring-readfile local Rostruct = loadstring ( readfile ( \"Rostruct.lua\" ))()","title":"with loadfile()"},{"location":"getting-started/overview/","text":"Getting started \u00b6 With Rostruct , script executors can run your Lua projects as Roblox Instances. Integrate powerful tools like Rojo and Selene for VS Code into your workflow, ensuring a hassle-free development experience. This documentation is a work in progress! What you need to know \u00b6 This guide assumes: You're familiar with development in an external code editor. If you're unsure of how to manage Roblox projects externally, or what we're trying to accomplish, check out the Rojo docs for a detailed explanation. You understand how to use Promises. Though the Promise-based API is optional, it's very useful. If you'd like to learn more, check out evaera's Promise library . Why Rostruct? \u00b6 When it comes to exploiting, projects are often developed and maintained within a single file. However, scripts that get too large become detrimental to your workflow. Over time, your project becomes more difficult to debug, maintain, and share. In contrast, with Rojo, your codebase gets turned directly into Roblox Instances. Taking this modular approach to exploiting can significantly improve the development experience. Rostruct's design complements a Rojo-based workflow, introducing script developers to a professional way to manage projects. Built for ambitious projects \u00b6 Rostruct executes multiple files at once, so you can focus on making your code readable, without worrying about the implementation. Create projects from UI libraries to explorers - with little to no limitations. Asset management \u00b6 Store all of your UI, modules, and assets locally, and they'll be loaded as Roblox objects before runtime. Write your code without waiting for assets. local midiPlayer = script : FindFirstAncestor ( \"MidiPlayer\" ) local Signal = require ( midiPlayer . Util . Signal ) local Date = require ( midiPlayer . Util . Date ) local Thread = require ( midiPlayer . Util . Thread ) local gui = midiPlayer . Assets . ScreenGui gui . Parent = gethui () Use projects anywhere \u00b6 Want to use a resource? Load Rostruct projects in your script with an intelligent Promise-based module system. Seamlessly integrate large projects with an easy-to-use API. local Roact = Rostruct . fetchLatest ( \"Roblox\" , \"roact\" ) : andThen ( function ( package ) package : build ( \"src/\" , { Name = \"Roact\" }) return package : require ( package . tree . Roact ) end ) : expect () Take advantage of model files \u00b6 If you're experienced with GitHub, you can set up a workflow to distribute your project as a *.rbxm model file. Decrease loading times with model files. local Roact = Rostruct . fetchLatest ( \"Roblox\" , \"roact\" , \"Roact.rbxm\" ) : andThen ( function ( package ) return package : require ( package : build ( \"Roact.rbxm\" ) ) end ) : expect () Test at any time \u00b6 Design your project with Rojo, a popular tool used to sync an external code editor with Roblox Studio. Write code, even during exploit downtime. Recommended tools \u00b6 Rostruct can (and should!) be paired with helpful tools like: Rojo - a project management tool Roblox LSP - full intellisense for Roblox and Luau in VS Code Selene for VS Code - a static analysis tool to help you write better Lua","title":"Overview"},{"location":"getting-started/overview/#getting-started","text":"With Rostruct , script executors can run your Lua projects as Roblox Instances. Integrate powerful tools like Rojo and Selene for VS Code into your workflow, ensuring a hassle-free development experience. This documentation is a work in progress!","title":"Getting started"},{"location":"getting-started/overview/#what-you-need-to-know","text":"This guide assumes: You're familiar with development in an external code editor. If you're unsure of how to manage Roblox projects externally, or what we're trying to accomplish, check out the Rojo docs for a detailed explanation. You understand how to use Promises. Though the Promise-based API is optional, it's very useful. If you'd like to learn more, check out evaera's Promise library .","title":"What you need to know"},{"location":"getting-started/overview/#why-rostruct","text":"When it comes to exploiting, projects are often developed and maintained within a single file. However, scripts that get too large become detrimental to your workflow. Over time, your project becomes more difficult to debug, maintain, and share. In contrast, with Rojo, your codebase gets turned directly into Roblox Instances. Taking this modular approach to exploiting can significantly improve the development experience. Rostruct's design complements a Rojo-based workflow, introducing script developers to a professional way to manage projects.","title":"Why Rostruct?"},{"location":"getting-started/overview/#built-for-ambitious-projects","text":"Rostruct executes multiple files at once, so you can focus on making your code readable, without worrying about the implementation. Create projects from UI libraries to explorers - with little to no limitations.","title":"Built for ambitious projects"},{"location":"getting-started/overview/#asset-management","text":"Store all of your UI, modules, and assets locally, and they'll be loaded as Roblox objects before runtime. Write your code without waiting for assets. local midiPlayer = script : FindFirstAncestor ( \"MidiPlayer\" ) local Signal = require ( midiPlayer . Util . Signal ) local Date = require ( midiPlayer . Util . Date ) local Thread = require ( midiPlayer . Util . Thread ) local gui = midiPlayer . Assets . ScreenGui gui . Parent = gethui ()","title":"Asset management"},{"location":"getting-started/overview/#use-projects-anywhere","text":"Want to use a resource? Load Rostruct projects in your script with an intelligent Promise-based module system. Seamlessly integrate large projects with an easy-to-use API. local Roact = Rostruct . fetchLatest ( \"Roblox\" , \"roact\" ) : andThen ( function ( package ) package : build ( \"src/\" , { Name = \"Roact\" }) return package : require ( package . tree . Roact ) end ) : expect ()","title":"Use projects anywhere"},{"location":"getting-started/overview/#take-advantage-of-model-files","text":"If you're experienced with GitHub, you can set up a workflow to distribute your project as a *.rbxm model file. Decrease loading times with model files. local Roact = Rostruct . fetchLatest ( \"Roblox\" , \"roact\" , \"Roact.rbxm\" ) : andThen ( function ( package ) return package : require ( package : build ( \"Roact.rbxm\" ) ) end ) : expect ()","title":"Take advantage of model files"},{"location":"getting-started/overview/#test-at-any-time","text":"Design your project with Rojo, a popular tool used to sync an external code editor with Roblox Studio. Write code, even during exploit downtime.","title":"Test at any time"},{"location":"getting-started/overview/#recommended-tools","text":"Rostruct can (and should!) be paired with helpful tools like: Rojo - a project management tool Roblox LSP - full intellisense for Roblox and Luau in VS Code Selene for VS Code - a static analysis tool to help you write better Lua","title":"Recommended tools"},{"location":"getting-started/publishing-your-project/","text":"Publishing your project \u00b6 Once you're ready to distribute your project, it's important to note that it should run automatically. Ideally, the end-user shouldn't do more than save a script. Fortunately, Rostruct provides functionality to deploy your codebase through GitHub: Deploying from GitHub \u00b6 The best way to publish your Rostruct project is by creating GitHub Releases in a repository. Rostruct will save and version-check the releases for you. You should write a retriever script that lets users run your project without any extra setup. The retriever handles the execution of your repo's latest GitHub Release. However, you'll need to load Rostruct to do that. Loading Rostruct \u00b6 In the retriever, you can load Rostruct in two ways: with an HTTP request, or from Rostruct's source code. Each option has its pros and cons, so choose whichever one best fits your project. with HTTP GET recommended \u00b6 If you prefer a quick and concise way to load Rostruct, you can load it with an HTTP request. To do this, you should pick a release from the GitHub Releases page , and copy the tag version to TAG_VERSION_HERE in this code: local Rostruct = loadstring ( game : HttpGetAsync ( \"https://github.com/richie0866/Rostruct/releases/download/\" .. \"TAG_VERSION_HERE\" .. \"/Rostruct.lua\" ))() This loads the Rostruct library by getting the source and executing it. You can now deploy your project . with source code \u00b6 If you don't want to make an HTTP request, you can load Rostruct instantly by using the source code in your script. In other words, you'll be using Rostruct as an internal module . To add Rostruct's source to your retriever, download the Rostruct.lua asset from your preferred release of Rostruct from the GitHub Releases page , and paste it into your retriever. This file should end with return Rostruct . Since you're going to use Rostruct, all you have to do is remove that line! Although this bloats up your file, unlike the first method, you can use Rostruct immediately. Running your project \u00b6 After you've loaded Rostruct, use Rostruct.fetch or Rostruct.fetchLatest to download and package the release files in your retriever. Deployment \u00b6 You can deploy your project using Rostruct's fetch functions, which return a Promise that resolves with a new Package object. It functions almost identically to using Rostruct.open , just with a Promise: Start -- Download the latest release to local files return Rostruct . fetchLatest ( \"richie0866\" , \"MidiPlayer\" ) -- Then, build and start all scripts : andThen ( function ( package ) package : build ( \"src/\" ) package : start () return package end ) -- Finally, wait until the Promise is done : expect () Require -- Download the latest release of Roact to local files return Rostruct . fetchLatest ( \"Roblox\" , \"roact\" ) -- Then, build and require Roact : andThen ( function ( package ) return package : require ( package : build ( \"src/\" , { Name = \"Roact\" }) ) end ) -- Finally, wait until the Promise is done, and -- return the result of package:require : expect () Now, anyone with this script can deploy your project in a Roblox script executor. Remember to test your code! You can simplify the script for end-user by saving the retriever in your repo and loading its source with HttpGetAsync : Distribution \u00b6 Some users may prefer a short and concise way to use your project. To account for this, you should provide additional code that uses the loadstring-HttpGet pattern to run your project's retriever. Loading your module through an HTTP request may seem counterproductive, but some developers may prefer it in a single-file project. So, your code should look something like this: local Foo = loadstring ( game : HttpGetAsync ( \"LINK_TO_RAW_RETRIEVER\" ))() RAW_RETRIEVER_URL should be replaced with a link to your retriever's raw contents. It may be in your best interest to load Rostruct internally to avoid the extra HTTP request.","title":"Publishing your project"},{"location":"getting-started/publishing-your-project/#publishing-your-project","text":"Once you're ready to distribute your project, it's important to note that it should run automatically. Ideally, the end-user shouldn't do more than save a script. Fortunately, Rostruct provides functionality to deploy your codebase through GitHub:","title":"Publishing your project"},{"location":"getting-started/publishing-your-project/#deploying-from-github","text":"The best way to publish your Rostruct project is by creating GitHub Releases in a repository. Rostruct will save and version-check the releases for you. You should write a retriever script that lets users run your project without any extra setup. The retriever handles the execution of your repo's latest GitHub Release. However, you'll need to load Rostruct to do that.","title":"Deploying from GitHub"},{"location":"getting-started/publishing-your-project/#loading-rostruct","text":"In the retriever, you can load Rostruct in two ways: with an HTTP request, or from Rostruct's source code. Each option has its pros and cons, so choose whichever one best fits your project.","title":"Loading Rostruct"},{"location":"getting-started/publishing-your-project/#with-http-get-recommended","text":"If you prefer a quick and concise way to load Rostruct, you can load it with an HTTP request. To do this, you should pick a release from the GitHub Releases page , and copy the tag version to TAG_VERSION_HERE in this code: local Rostruct = loadstring ( game : HttpGetAsync ( \"https://github.com/richie0866/Rostruct/releases/download/\" .. \"TAG_VERSION_HERE\" .. \"/Rostruct.lua\" ))() This loads the Rostruct library by getting the source and executing it. You can now deploy your project .","title":"with HTTP GET"},{"location":"getting-started/publishing-your-project/#with-source-code","text":"If you don't want to make an HTTP request, you can load Rostruct instantly by using the source code in your script. In other words, you'll be using Rostruct as an internal module . To add Rostruct's source to your retriever, download the Rostruct.lua asset from your preferred release of Rostruct from the GitHub Releases page , and paste it into your retriever. This file should end with return Rostruct . Since you're going to use Rostruct, all you have to do is remove that line! Although this bloats up your file, unlike the first method, you can use Rostruct immediately.","title":"with source code"},{"location":"getting-started/publishing-your-project/#running-your-project","text":"After you've loaded Rostruct, use Rostruct.fetch or Rostruct.fetchLatest to download and package the release files in your retriever.","title":"Running your project"},{"location":"getting-started/publishing-your-project/#deployment","text":"You can deploy your project using Rostruct's fetch functions, which return a Promise that resolves with a new Package object. It functions almost identically to using Rostruct.open , just with a Promise: Start -- Download the latest release to local files return Rostruct . fetchLatest ( \"richie0866\" , \"MidiPlayer\" ) -- Then, build and start all scripts : andThen ( function ( package ) package : build ( \"src/\" ) package : start () return package end ) -- Finally, wait until the Promise is done : expect () Require -- Download the latest release of Roact to local files return Rostruct . fetchLatest ( \"Roblox\" , \"roact\" ) -- Then, build and require Roact : andThen ( function ( package ) return package : require ( package : build ( \"src/\" , { Name = \"Roact\" }) ) end ) -- Finally, wait until the Promise is done, and -- return the result of package:require : expect () Now, anyone with this script can deploy your project in a Roblox script executor. Remember to test your code! You can simplify the script for end-user by saving the retriever in your repo and loading its source with HttpGetAsync :","title":"Deployment"},{"location":"getting-started/publishing-your-project/#distribution","text":"Some users may prefer a short and concise way to use your project. To account for this, you should provide additional code that uses the loadstring-HttpGet pattern to run your project's retriever. Loading your module through an HTTP request may seem counterproductive, but some developers may prefer it in a single-file project. So, your code should look something like this: local Foo = loadstring ( game : HttpGetAsync ( \"LINK_TO_RAW_RETRIEVER\" ))() RAW_RETRIEVER_URL should be replaced with a link to your retriever's raw contents. It may be in your best interest to load Rostruct internally to avoid the extra HTTP request.","title":"Distribution"},{"location":"getting-started/using-other-projects/","text":"Using other projects \u00b6 Note This page is mainly for loading Rostruct projects in another project , and not in a single file. In a project distributed as a single script, you should load multi-file dependencies using the functions Rostruct provides, like fetch and fetchLatest . Using resources like libraries and utility modules in your projects can make development easier. However, resources aren't always distributed as a single Lua script. For example, a UI library could be released as a Rostruct project that loads itself like this: local Rostruct = loadstring ( game : HttpGetAsync ( \"https://github.com/richie0866/Rostruct/releases/download/v1.2.3/Rostruct.lua\" ))() local package = Rostruct . fetchAsync ( \"stickmasterluke\" , \"MyModule\" ) local myModule = package : build ( \"src/\" , { Name = \"MyModule\" }) return package : requireAsync ( myModule ) This is valid code in a Rostruct project. However, Rostruct is early in development, and may have unwanted side effects when using it inside a Rostruct project. This might change in the future, though. Exercise caution when using Rostruct in a Rostruct project, or opt for another solution: Download it manually \u00b6 Warning This method to load dependencies may be deprecated in favor of using Rostruct internally, so stay notified by watching the GitHub repository. One way to load a dependency in your project is to include their source files in your codebase. You can download it with these steps: Download the project's latest GitHub Release If their retriever fetches a specific asset, then download that asset Move the source somewhere in your project If the source folder needs specific properties before runtime, use an init.meta.json file to set the properties, if not already provided. If only the name is changed, change the name of the directory in your project files. Use require () to load the module in your project Once you've set up the files, Rostruct turns the dependencies into instances with the rest of your project, ensuring immediate access to them. You should use the global require () function to load them: local myProject = script : FindFirstAncestor ( \"MyProject\" ) local Roact = require ( myProject . Modules . Roact ) local character = myProject . Assets . Character","title":"Using other projects"},{"location":"getting-started/using-other-projects/#using-other-projects","text":"Note This page is mainly for loading Rostruct projects in another project , and not in a single file. In a project distributed as a single script, you should load multi-file dependencies using the functions Rostruct provides, like fetch and fetchLatest . Using resources like libraries and utility modules in your projects can make development easier. However, resources aren't always distributed as a single Lua script. For example, a UI library could be released as a Rostruct project that loads itself like this: local Rostruct = loadstring ( game : HttpGetAsync ( \"https://github.com/richie0866/Rostruct/releases/download/v1.2.3/Rostruct.lua\" ))() local package = Rostruct . fetchAsync ( \"stickmasterluke\" , \"MyModule\" ) local myModule = package : build ( \"src/\" , { Name = \"MyModule\" }) return package : requireAsync ( myModule ) This is valid code in a Rostruct project. However, Rostruct is early in development, and may have unwanted side effects when using it inside a Rostruct project. This might change in the future, though. Exercise caution when using Rostruct in a Rostruct project, or opt for another solution:","title":"Using other projects"},{"location":"getting-started/using-other-projects/#download-it-manually","text":"Warning This method to load dependencies may be deprecated in favor of using Rostruct internally, so stay notified by watching the GitHub repository. One way to load a dependency in your project is to include their source files in your codebase. You can download it with these steps: Download the project's latest GitHub Release If their retriever fetches a specific asset, then download that asset Move the source somewhere in your project If the source folder needs specific properties before runtime, use an init.meta.json file to set the properties, if not already provided. If only the name is changed, change the name of the directory in your project files. Use require () to load the module in your project Once you've set up the files, Rostruct turns the dependencies into instances with the rest of your project, ensuring immediate access to them. You should use the global require () function to load them: local myProject = script : FindFirstAncestor ( \"MyProject\" ) local Roact = require ( myProject . Modules . Roact ) local character = myProject . Assets . Character","title":"Download it manually"}]}